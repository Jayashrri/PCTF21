# WriteUp

- This seems to be a reversing challenge. So I'll be using gdb with pwndbg and
  ghidra.

- Running the binary

```bash
Enter 10 numbers to check your luck
1
2
3
4
5
6
7
8
9
10
You have failed
```

- Analysing in gdb
  - There seems to be two global variables, arr and match
  - arr seems to be a character arr. With value "DeltaForce"
  - match seems to be an integer array with 10 elements all having some values.

```bash
pwndbg> info variables
All defined variables:

Non-debugging symbols:
0x00000000000002e8  __abi_tag
0x0000000000002000  _IO_stdin_used
0x000000000000204c  __GNU_EH_FRAME_HDR
0x00000000000021a4  __FRAME_END__
0x0000000000003de8  __frame_dummy_init_array_entry
0x0000000000003de8  __init_array_start
0x0000000000003df0  __do_global_dtors_aux_fini_array_entry
0x0000000000003df0  __init_array_end
0x0000000000003df8  _DYNAMIC
0x0000000000004000  _GLOBAL_OFFSET_TABLE_
0x0000000000004060  __data_start
0x0000000000004060  data_start
0x0000000000004068  __dso_handle
0x0000000000004080  match
0x00000000000040c0  arr
0x00000000000040e8  __TMC_END__
0x00000000000040e8  __bss_start
0x00000000000040e8  _edata
0x00000000000040e8  stdout
0x00000000000040e8  stdout@@GLIBC_2.2.5
0x00000000000040f0  completed
0x00000000000040f8  _end
pwndbg> print &arr
$2 = (<data variable, no debug info> *) 0x40c0 <arr>
pwndbg> x/20wx &arr
0x40c0 <arr>:   0x746c6544      0x726f4661      0x00006563      0x00000000
0x40d0 <arr+16>:        0x00000000      0x00000000      0x00000000      0x00000000
0x40e0 <arr+32>:        0x00000000      0x00000000      0x00000000      0x00000000
0x40f0 <completed.0>:   0x00000000      0x00000000      Cannot access memory at
address 0x40f8
pwndbg> x/s &arr
0x40c0 <arr>:   "DeltaForce"
pwndbg> print &match
$4 = (<data variable, no debug info> *) 0x4080 <match>
pwndbg> x/s &match
0x4080 <match>: "\b\251S6x\242a\035Q\367zDo(\312\177\071", <incomplete sequence \351>
pwndbg> x/20wx &match
0x4080 <match>: 0x3653a908      0x1d61a278      0x447af751      0x7fca286f
0x4090 <match+16>:      0x00e92139      0x26435140      0x52d77ebe      0x03ef04fd
0x40a0 <match+32>:      0x47d10b31      0x4e930de2      0x00000000      0x00000000
0x40b0: 0x00000000      0x00000000      0x00000000      0x00000000
0x40c0 <arr>:   0x746c6544      0x726f4661      0x00006563      0x00000000
pwndbg> x/10wx &match
0x4080 <match>: 0x3653a908      0x1d61a278      0x447af751      0x7fca286f
0x4090 <match+16>:      0x00e92139      0x26435140      0x52d77ebe      0x03ef04fd
0x40a0 <match+32>:      0x47d10b31      0x4e930de2
pwndbg> disassemble main
Dump of assembler code for function main:
   0x00000000000010a0 <+0>:     push   r12
   0x00000000000010a2 <+2>:     mov    edx,0xa
   0x00000000000010a7 <+7>:     mov    edi,0xcccccccd
   0x00000000000010ac <+12>:    lea    rsi,[rip+0x300d]        # 0x40c0 <arr>
   0x00000000000010b3 <+19>:    push   rbp
   0x00000000000010b4 <+20>:    push   rbx
   0x00000000000010b5 <+21>:    sub    rsp,0x60
   0x00000000000010b9 <+25>:    mov    rax,QWORD PTR fs:0x28
   0x00000000000010c2 <+34>:    mov    QWORD PTR [rsp+0x58],rax
   0x00000000000010c7 <+39>:    xor    eax,eax
   0x00000000000010c9 <+41>:    nop    DWORD PTR [rax+0x0]
   0x00000000000010d0 <+48>:    mov    eax,edx
   0x00000000000010d2 <+50>:    imul   rax,rdi
   0x00000000000010d6 <+54>:    shr    rax,0x23
   0x00000000000010da <+58>:    lea    ecx,[rax+rax*4]
   0x00000000000010dd <+61>:    mov    eax,edx
   0x00000000000010df <+63>:    add    ecx,ecx
   0x00000000000010e1 <+65>:    sub    eax,ecx
   0x00000000000010e3 <+67>:    cdqe
   0x00000000000010e5 <+69>:    movzx  eax,BYTE PTR [rsi+rax*1]
   0x00000000000010e9 <+73>:    mov    BYTE PTR [rsi+rdx*1],al
   0x00000000000010ec <+76>:    add    rdx,0x1
   0x00000000000010f0 <+80>:    cmp    rdx,0x28
   0x00000000000010f4 <+84>:    jne    0x10d0 <main+48>
   0x00000000000010f6 <+86>:    mov    edi,0xffffff
   0x00000000000010fb <+91>:    mov    rbx,rsp
   0x00000000000010fe <+94>:    lea    r12,[rsp+0x28]
   0x0000000000001103 <+99>:    call   0x1060 <srand@plt>
   0x0000000000001108 <+104>:   lea    rdi,[rip+0xef9]        # 0x2008
   0x000000000000110f <+111>:   lea    rbp,[rip+0xf16]        # 0x202c
   0x0000000000001116 <+118>:   call   0x1030 <puts@plt>
   0x000000000000111b <+123>:   mov    rdi,QWORD PTR [rip+0x2fc6]        # 0x40e8 <stdout@@GLIBC_2.2.5>
   0x0000000000001122 <+130>:   call   0x1070 <fflush@plt>
   0x0000000000001127 <+135>:   nop    WORD PTR [rax+rax*1+0x0]
   0x0000000000001130 <+144>:   mov    rsi,rbx
   0x0000000000001133 <+147>:   mov    rdi,rbp
   0x0000000000001136 <+150>:   xor    eax,eax
   0x0000000000001138 <+152>:   add    rbx,0x4
   0x000000000000113c <+156>:   call   0x1080 <__isoc99_scanf@plt>
   0x0000000000001141 <+161>:   cmp    r12,rbx
   0x0000000000001144 <+164>:   jne    0x1130 <main+144>
   0x0000000000001146 <+166>:   pxor   xmm0,xmm0
   0x000000000000114a <+170>:   lea    rbp,[rsp+0x30]
   0x000000000000114f <+175>:   lea    r12,[rsp+0x58]
   0x0000000000001154 <+180>:   mov    QWORD PTR [rsp+0x50],0x0
   0x000000000000115d <+189>:   movaps XMMWORD PTR [rsp+0x30],xmm0
   0x0000000000001162 <+194>:   movaps XMMWORD PTR [rsp+0x40],xmm0
   0x0000000000001167 <+199>:   nop    WORD PTR [rax+rax*1+0x0]
   0x0000000000001170 <+208>:   mov    ebx,0x5
   0x0000000000001175 <+213>:   call   0x1090 <rand@plt>
   0x000000000000117a <+218>:   xor    DWORD PTR [rbp+0x0],eax
   0x000000000000117d <+221>:   sub    ebx,0x1
   0x0000000000001180 <+224>:   jne    0x1175 <main+213>
   0x0000000000001182 <+226>:   add    rbp,0x4
   0x0000000000001186 <+230>:   cmp    rbp,r12
   0x0000000000001189 <+233>:   jne    0x1170 <main+208>
   0x000000000000118b <+235>:   movq   xmm2,QWORD PTR [rsp+0x50]
   0x0000000000001191 <+241>:   movq   xmm3,QWORD PTR [rsp+0x20]
   0x0000000000001197 <+247>:   movdqa xmm0,XMMWORD PTR [rsp+0x30]
   0x000000000000119d <+253>:   pxor   xmm0,XMMWORD PTR [rsp]
   0x00000000000011a2 <+258>:   pxor   xmm2,xmm3
   0x00000000000011a6 <+262>:   pxor   xmm0,XMMWORD PTR [rip+0x2f12]        # 0x40c0 <arr>
   0x00000000000011ae <+270>:   movq   xmm3,QWORD PTR [rip+0x2f2a]        # 0x40e0 <arr+32>
   0x00000000000011b6 <+278>:   movdqa xmm1,XMMWORD PTR [rsp+0x10]
   0x00000000000011bc <+284>:   pxor   xmm1,XMMWORD PTR [rsp+0x40]
   0x00000000000011c2 <+290>:   pxor   xmm1,XMMWORD PTR [rip+0x2f06]        # 0x40d0 <arr+16>
   0x00000000000011ca <+298>:   pxor   xmm2,xmm3
   0x00000000000011ce <+302>:   movd   eax,xmm0
   0x00000000000011d2 <+306>:   cmp    DWORD PTR [rip+0x2ea8],eax        # 0x4080 <match>
   0x00000000000011d8 <+312>:   movaps XMMWORD PTR [rsp+0x30],xmm0
   0x00000000000011dd <+317>:   movaps XMMWORD PTR [rsp+0x40],xmm1
   0x00000000000011e2 <+322>:   movq   QWORD PTR [rsp+0x50],xmm2
   0x00000000000011e8 <+328>:   jne    0x12b6 <main+534>
   0x00000000000011ee <+334>:   pshufd xmm3,xmm0,0x55
   0x00000000000011f3 <+339>:   movd   eax,xmm3
   0x00000000000011f7 <+343>:   cmp    DWORD PTR [rip+0x2e87],eax        # 0x4084 <match+4>
   0x00000000000011fd <+349>:   jne    0x12b6 <main+534>
   0x0000000000001203 <+355>:   movdqa xmm3,xmm0
   0x0000000000001207 <+359>:   punpckhdq xmm3,xmm0
   0x000000000000120b <+363>:   movd   eax,xmm3
   0x000000000000120f <+367>:   cmp    DWORD PTR [rip+0x2e73],eax        # 0x4088 <match+8>
   0x0000000000001215 <+373>:   jne    0x12b6 <main+534>
   0x000000000000121b <+379>:   pshufd xmm0,xmm0,0xff
   0x0000000000001220 <+384>:   movd   eax,xmm0
   0x0000000000001224 <+388>:   cmp    eax,DWORD PTR [rip+0x2e62]        # 0x408c <match+12>
   0x000000000000122a <+394>:   jne    0x12b6 <main+534>
   0x0000000000001230 <+400>:   movd   eax,xmm1
   0x0000000000001234 <+404>:   cmp    eax,DWORD PTR [rip+0x2e56]        # 0x4090 <match+16>
   0x000000000000123a <+410>:   jne    0x12b6 <main+534>
   0x000000000000123c <+412>:   pshufd xmm0,xmm1,0x55
   0x0000000000001241 <+417>:   movd   eax,xmm0
   0x0000000000001245 <+421>:   cmp    eax,DWORD PTR [rip+0x2e49]        # 0x4094 <match+20>
   0x000000000000124b <+427>:   jne    0x12b6 <main+534>
   0x000000000000124d <+429>:   movdqa xmm0,xmm1
   0x0000000000001251 <+433>:   punpckhdq xmm0,xmm1
   0x0000000000001255 <+437>:   movd   eax,xmm0
   0x0000000000001259 <+441>:   cmp    eax,DWORD PTR [rip+0x2e39]        # 0x4098 <match+24>
   0x000000000000125f <+447>:   jne    0x12b6 <main+534>
   0x0000000000001261 <+449>:   pshufd xmm1,xmm1,0xff
   0x0000000000001266 <+454>:   movd   eax,xmm1
   0x000000000000126a <+458>:   cmp    eax,DWORD PTR [rip+0x2e2c]        # 0x409c <match+28>
   0x0000000000001270 <+464>:   jne    0x12b6 <main+534>
   0x0000000000001272 <+466>:   movd   eax,xmm2
   0x0000000000001276 <+470>:   cmp    eax,DWORD PTR [rip+0x2e24]        # 0x40a0 <match+32>
   0x000000000000127c <+476>:   jne    0x12b6 <main+534>
   0x000000000000127e <+478>:   pshufd xmm4,xmm2,0xe5
   0x0000000000001283 <+483>:   movd   eax,xmm4
   0x0000000000001287 <+487>:   cmp    DWORD PTR [rip+0x2e17],eax        # 0x40a4 <match+36>
   0x000000000000128d <+493>:   jne    0x12b6 <main+534>
   0x000000000000128f <+495>:   lea    rdi,[rip+0xd9a]        # 0x2030
   0x0000000000001296 <+502>:   call   0x1050 <system@plt>
   0x000000000000129b <+507>:   mov    rax,QWORD PTR [rsp+0x58]
   0x00000000000012a0 <+512>:   sub    rax,QWORD PTR fs:0x28
   0x00000000000012a9 <+521>:   jne    0x12c4 <main+548>
   0x00000000000012ab <+523>:   add    rsp,0x60
   0x00000000000012af <+527>:   xor    eax,eax
   0x00000000000012b1 <+529>:   pop    rbx
   0x00000000000012b2 <+530>:   pop    rbp
   0x00000000000012b3 <+531>:   pop    r12
   0x00000000000012b5 <+533>:   ret
   0x00000000000012b6 <+534>:   lea    rdi,[rip+0xd85]        # 0x2042
   0x00000000000012bd <+541>:   call   0x1030 <puts@plt>
   0x00000000000012c2 <+546>:   jmp    0x129b <main+507>
   0x00000000000012c4 <+548>:   call   0x1040 <__stack_chk_fail@plt>
End of assembler dump.

```

- Firing up ghidra, we see this as the main function

```C

/* WARNING: Could not reconcile some variable overlaps */
/* WARNING: Globals starting with '_' overlap smaller symbols at the
same address */

undefined8 main(void)

{
    // damn thats a lot of variables
  uint uVar1;
  ulong uVar2;
  int iVar3;
  uint *puVar4;
  undefined *puVar5;
  long *plVar6;
  long in_FS_OFFSET;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  uint local_78;
  uint uStack116;
  uint uStack112;
  uint uStack108;
  uint local_68;
  uint uStack100;
  uint uStack96;
  uint uStack92;
  ulong local_58;
  undefined local_50 [8];
  undefined local_48 [8];
  uint uStack64;
  uint uStack60;
  undefined local_38 [8];
  uint uStack48;
  uint uStack44;
  ulong local_28;
  long local_20;

  uVar2 = 10;  // this seems to be the loop variable
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  // this loop seems to be filling something in a global variable called arr
  //starting from 10 to 40
  do {
      /* here its just doing arr[uVar2] = arr[uVar2+ (uVar2/10) * (-10)]
       I have no idea why theres an and with 0xffffffff because that
       doesnt really change anything
       we can notice that "uVar2 - (uVar2/10) * 10 " == uVar2 % 10
       so basically here in loop body, it's just saying arr[uVar2]=arr[uVar2%10]
       We know that arr variable contains "DeltaForce" and this seeems to be
       copying that
       to other places in arr as everything else contained zeros (seen in gdb output)
       After doing this the arr global variable will probably look like this
       "DeltaForceDeltaForceDeltaForceDeltaForce"  */
    arr[uVar2] = arr[(int)uVar2 + (int)((uVar2 & 0xffffffff) / 10) * -10];
    uVar2 = uVar2 + 1;
  } while (uVar2 != 0x28); // goes from uVar2 <- 10 to 40
  srand(0xffffff); // a fixed seed call to srand
  puts("Enter 10 numbers to check your luck");
  fflush(stdout);
  puVar4 = &local_78;
  // This loop will run ten times .
  // Its not obvious from this decompiled code but we know it will run 10 times
  // because I ran the binary and it prompted for 10 inputs
  do {
    puVar5 = (undefined *)((long)puVar4 + 4);
    __isoc99_scanf(&DAT_0010202c,puVar4);
    puVar4 = (uint *)puVar5;
  } while (local_50 != puVar5);
  // no clue what this is for
  plVar6 = (long *)local_48;
  local_28 = 0;
  _local_48 = (undefined  [16])0x0;
  _local_38 = (undefined  [16])0x0;
  do {
    iVar3 = 5; // inner loop variable
    do {
    /*
    What I can understand here is, It is generating a random number
    and then xors it with plVar6 and this is running 5 times
    The inside loop runs 5 times but its not clear to me how many
    times the  outer loop run
    so basically *(uint *plVar6)= rand() ^ rand() ^ rand() ^ rand() ^ rand();
    */
      uVar1 = rand();
      *(uint *)plVar6 = *(uint *)plVar6 ^ uVar1;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    // increments the pointer right after coming out of the loop
    plVar6 = (long *)((long)plVar6 + 4);
  // what we want to know to determine the no of iterations is the
  // offset of local_20 and the initial value of plVar6
  } while (plVar6 != &local_20);

  // I'll figure this part out from the binary

  uVar1 = local_48._0_4_ ^ local_78 ^ arr._0_4_;
  uVar7 = local_48._4_4_ ^ uStack116 ^ arr._4_4_;
  uVar8 = uStack64 ^ uStack112 ^ ram0x001040c8;
  uVar9 = uStack60 ^ uStack108 ^ uRam00000000001040cc;
  uVar10 = local_68 ^ local_38._0_4_ ^ _DAT_001040d0;
  uVar11 = uStack100 ^ local_38._4_4_ ^ uRam00000000001040d4;
  uVar12 = uStack96 ^ uStack48 ^ uRam00000000001040d8;
  uVar13 = uStack92 ^ uStack44 ^ uRam00000000001040dc;
  local_28 = local_28 ^ local_58 ^ _DAT_001040e0;
  _local_48 = CONCAT412(uVar9,CONCAT48(uVar8,CONCAT44(uVar7,uVar1)));
  _local_38 = CONCAT412(uVar13,CONCAT48(uVar12,CONCAT44(uVar11,uVar10)));
  if ((((((match._0_4_ == uVar1) && (match._4_4_ == uVar7)) && (match._8_4_ == uVar8)) &&
       ((uVar9 == match._12_4_ && (uVar10 == match._16_4_)))) &&
      ((uVar11 == match._20_4_ && ((uVar12 == match._24_4_ && (uVar13 == match._28_4_)))))) &&
     (((int)local_28 == match._32_4_ && (match._36_4_ == SUB164(ZEXT816(local_28) >> 0x20,0))))) {
    system("/bin/cat flag.txt");
  }
  else {
    puts("You have failed");
  }
  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {
    return 0;
  }
                    /* WARNING: Subroutine does not return */
  __stack_chk_fail();
}
```

- There's a loop after all the input taking. Inside that loop there seems to be
  another loop which seems to be running 5 times. But the outerloop I cant quite
  understand how many times its running. But when I saw the corresponding
  assembly, it was obvious. It runs 10 times. So what its doing is putting xor
  of 5 random numbers in each of the 10 positions in some array probably. We can
  also be sure that initially the array was filled with all zeros. The xmm0
  register is a 128 bit register and at <main+166> , there was an instruction
  that zeroed this out `pxor xmm0,xmm0`. More details about xmm registers can be
  found [here](https://en.wikibooks.org/wiki/X86_Assembly/SSE). In this snippet,
  we see [rsp+0x50] set to 0 as QWORD(meaning 8 bytes, so from 0x50 to 0x58).
  After that [rsp+0x30] and [rsp+0x40] were set to zero by movaps instruction.
  The xmm registers are 128 bits registers which can be used to store different
  variants of data. We can see that from the link above.

  ```bash
    114a:       48 8d 6c 24 30          lea    rbp,[rsp+0x30] // starts from 0x30
    114f:       4c 8d 64 24 58          lea    r12,[rsp+0x58] // goes till 0x58
    1154:       48 c7 44 24 50 00 00    mov    QWORD PTR [rsp+0x50],0x0
    115b:       00 00
    115d:       0f 29 44 24 30          movaps XMMWORD PTR [rsp+0x30],xmm0
    1162:       0f 29 44 24 40          movaps XMMWORD PTR [rsp+0x40],xmm0
    1167:       66 0f 1f 84 00 00 00    nop    WORD PTR [rax+rax*1+0x0]
    116e:       00 00
    1170:       bb 05 00 00 00          mov    ebx,0x5
    1175:       e8 16 ff ff ff          call   1090 <rand@plt>
    117a:       31 45 00                xor    DWORD PTR [rbp+0x0],eax
    117d:       83 eb 01                sub    ebx,0x1
    1180:       75 f3                   jne    1175 <main+0xd5>
    1182:       48 83 c5 04             add    rbp,0x4
    1186:       4c 39 e5                cmp    rbp,r12
    1189:       75 e5                   jne    1170 <main+0xd0>
  ```

- From this snippet , we can conclude the input array is stored at rsp, and goes
  on till rsp+0x28

```bash
   0x00000000000010fb <+91>:    mov    rbx,rsp
   0x00000000000010fe <+94>:    lea    r12,[rsp+0x28]
   0x0000000000001103 <+99>:    call   0x1060 <srand@plt>
   0x0000000000001108 <+104>:   lea    rdi,[rip+0xef9]        # 0x2008
   0x000000000000110f <+111>:   lea    rbp,[rip+0xf16]        # 0x202c
   0x0000000000001116 <+118>:   call   0x1030 <puts@plt>
   0x000000000000111b <+123>:   mov    rdi,QWORD PTR [rip+0x2fc6]        # 0x40e8 <stdout@@GLIBC_2.2.5>
   0x0000000000001122 <+130>:   call   0x1070 <fflush@plt>
   0x0000000000001127 <+135>:   nop    WORD PTR [rax+rax*1+0x0]
   0x0000000000001130 <+144>:   mov    rsi,rbx
   0x0000000000001133 <+147>:   mov    rdi,rbp
   0x0000000000001136 <+150>:   xor    eax,eax
   0x0000000000001138 <+152>:   add    rbx,0x4
   0x000000000000113c <+156>:   call   0x1080 <__isoc99_scanf@plt>
   0x0000000000001141 <+161>:   cmp    r12,rbx
   0x0000000000001144 <+164>:   jne    0x1130 <main+144>
```

- As of now , I know there are 10 inputs and they are stored from
  `rsp to rsp+0x28`. There's another array of 10 numbers, stored at
  `rsp+0x30 to rsp+0x58` which contains a bunch of random numbers xor'd
  together. Also we know there's a global variable `arr` which contains
  "DeltaForceDeltaForceDeltaForceDeltaForce" after the first loop ran. There's
  another global variable `match` which has some hardcoded numbers.

```
   0x000000000000118b <+235>:   movq   xmm2,QWORD PTR [rsp+0x50]
   0x0000000000001191 <+241>:   movq   xmm3,QWORD PTR [rsp+0x20]
   0x0000000000001197 <+247>:   movdqa xmm0,XMMWORD PTR [rsp+0x30]
   0x000000000000119d <+253>:   pxor   xmm0,XMMWORD PTR [rsp]
   0x00000000000011a2 <+258>:   pxor   xmm2,xmm3
```

- Here, rsp+50 is moved to xmm2, and rsp+0x20 is moved to xmm3. So these two sse
  registers xmm2 and xmm3 are storing last 2 numbers of the random number array
  and our input array. I am also going through gdb on the side and indeed they
  store those things. My input was 1 2 3 4 5 6 7 8 9 10. And the last two
  numbers are there in xmm3 just as I suspected. And I assume the numbers in
  xmm2 are the last two random numbers.

  ```bash
  pwndbg> print $xmm3
  $3 = {
    v8_bfloat16 = {8.265e-40, 0, 9.184e-40, 0, 0, 0, 0, 0},
    v4_float = {1.26116862e-44, 1.40129846e-44, 0, 0},
    v2_double = {2.1219957914099314e-313, 0},
    v16_int8 = {9, 0, 0, 0, 10, 0 <repeats 11 times>},
    v8_int16 = {9, 0, 10, 0, 0, 0, 0, 0},
    v4_int32 = {9, 10, 0, 0},
    v2_int64 = {42949672969, 0},
    uint128 = 42949672969
  }
  pwndbg> print $xmm2
  $4 = {
    v8_bfloat16 = {-8.303e+31, 2.372e-05, 1.921e-14, 8.367e-11, 0, 0, 0, 0},
    v4_float = {2.38365083e-05, 8.37457673e-11, 0, 0},
    v2_double = {1.2435929350595585e-83, 0},
    v16_int8 = {-125, -12, -57, 55, -83, 40, -72, 46, 0, 0, 0, 0, 0, 0, 0, 0},
    v8_int16 = {-2941, 14279, 10413, 11960, 0, 0, 0, 0},
    v4_int32 = {935851139, 783820973, 0, 0},
    v2_int64 = {3366485445889750147, 0},
    uint128 = 3366485445889750147
  }
  ```

- Right after that, first 4 elements of random numbers is moved into the 128 bit
  register xmm0. After that, it is xor'd with the input arrays's first 4
  numbers. And then did `xmm2 ^= xmm3` after that. Here basically, xmm2 =
  inputArr[8..9]^ randomNum[8..9]

  ```bash

  pwndbg> print $xmm0
  $9 = {
    v8_bfloat16 = {-3.934e-05, 1.182e-08, -4.179e+18, 2.516, -1.662e+37, 1.395e+13, 4.793e+30, 4.526e+17},
    v4_float = {1.18580248e-08, 2.5291996, 1.40180434e+13, 4.53618434e+17},
    v2_double = {8.9343887059622578, 9.4699041328615547e+138},
    v16_int8 = {37, -72, 75, 50, 104, -34, 33, 64, 72, -3, 75, 85, 114, 114, -55, 92},
    v8_int16 = {-18395, 12875, -8600, 16417, -696, 21835, 29298, 23753},
    v4_int32 = {843823141, 1075961448, 1431043400, 1556705906},
    v2_int64 = {4621219231760627749, 6686000957191093576},
    uint128 = 123334948533881194939840081547418646565
  }
  pwndbg> x/10d $rsp+0x30
  0x7fffffffe110: 843823140       1075961450      1431043403      1556705910
  0x7fffffffe120: 316356473       85345072        1910202552      1722507678
  0x7fffffffe130: 935851139       783820973
  pwndbg> x/10d $rsp
  0x7fffffffe0e0: 1       2       3       4
  0x7fffffffe0f0: 5       6       7       8
  0x7fffffffe100: 9       10
  pwndbg> print $xmm2
  $10 = {
  v8_bfloat16 = {-8.747e+31, 2.372e-05, 1.854e-14, 8.367e-11, 0, 0, 0, 0},
  v4_float = {2.3836521e-05, 8.37457256e-11, 0, 0},
  v2_double = {1.2435882223298331e-83, 0},
  v16_int8 = {-118, -12, -57, 55, -89, 40, -72, 46, 0, 0, 0, 0, 0, 0, 0, 0},
  v8_int16 = {-2934, 14279, 10407, 11960, 0, 0, 0, 0},
  v4_int32 = {935851146, 783820967, 0, 0},
  v2_int64 = {3366485420119946378, 0},
  uint128 = 3366485420119946378
  }
  ```

- After that the arr global variable arr is being used.

```bash
 ► 0x5555555551a6 <main+262>    pxor   xmm0, xmmword ptr [rip + 0x2f12] <0x5555555580c0> <- this is arr
   0x5555555551ae <main+270>    movq   xmm3, qword ptr [rip + 0x2f2a] <0x5555555580e0> <- this is arr + 0x20
   0x5555555551b6 <main+278>    movdqa xmm1, xmmword ptr [rsp + 0x10]
   0x5555555551bc <main+284>    pxor   xmm1, xmmword ptr [rsp + 0x40]
   0x5555555551c2 <main+290>    pxor   xmm1, xmmword ptr [rip + 0x2f06] <0x5555555580d0> <- this is arr+0x10
   0x5555555551ca <main+298>    pxor   xmm2, xmm3
   0x5555555551ce <main+302>    movd   eax, xmm0
```

- At <main+262>, First xmm0 which had xor of input arr and random arr's first 4
  elements is xor'd with arr's first 16 bytes. I'm saying bytes because it seems
  to have been a character array.
- That means `xmm0 = inputArr[0..3] ^ randomNum[0..3] ^ arr[0x0..0x0f]`
- At <main+270>, Then the last 8 bytes of arr is being moved to xmm3 register.
- So xmm3 = arr[0x20..0x27]
- At <main+278> rsp+10 (the 4-7 indices of input array ) is moved to xmm1
- At <main+284> rsp+40 (the 4-7 indices of random number array) is xor'd with
  xmm1
- At <main+290>, again xmm1 is xor'd with arr+0x10 to arr+0x1f.
- `So overall xmm1 = inputArr[4..7] ^ randomNum[4..7] ^ arr[0x10..0x1f]`
- At <main+298>, xmm2 is xor'd with new xmm3. So now
  `xmm2 = inputArr[8..9]^ randomNum[8..9] ^ arr[0x20..0x27]`

```bash

   0x00005555555551ce <+302>:   movd   eax,xmm0
=> 0x00005555555551d2 <+306>:   cmp    DWORD PTR [rip+0x2ea8],eax        # 0x555555558080 <match>
   0x00005555555551d8 <+312>:   movaps XMMWORD PTR [rsp+0x30],xmm0
   0x00005555555551dd <+317>:   movaps XMMWORD PTR [rsp+0x40],xmm1
   0x00005555555551e2 <+322>:   movq   QWORD PTR [rsp+0x50],xmm2
   0x00005555555551e8 <+328>:   jne    0x5555555552b6 <main+534>
   0x00005555555551ee <+334>:   pshufd xmm3,xmm0,0x55
   0x00005555555551f3 <+339>:   movd   eax,xmm3
   0x00005555555551f7 <+343>:   cmp    DWORD PTR [rip+0x2e87],eax        # 0x555555558084 <match+4>
   0x00005555555551fd <+349>:   jne    0x5555555552b6 <main+534>
   0x0000555555555203 <+355>:   movdqa xmm3,xmm0
   0x0000555555555207 <+359>:   punpckhdq xmm3,xmm0
   0x000055555555520b <+363>:   movd   eax,xmm3
   0x000055555555520f <+367>:   cmp    DWORD PTR [rip+0x2e73],eax        # 0x555555558088 <match+8>
```

- At <main+302> , it just moved the first 4 byte of xmm0 to eax and right after
  that its comparing that with [match+0].
- At main+312,317,322, the content of xmm registers is being moved to the random
  number array.
- At <main+328>, its checking the flags to see weather last comparision which
  was between eax and match[0] resulted in an inequality. If it did it will jump
  to <main+534>, which seems to be a puts call. I guess that's responsible for
  printing "You have failed", like it did for me in my attempt.
- Looking back at ghidra, there are 10 comparisions and although its not clear
  from ghidra, its clear from gdb that these are all comparision
  `randomNum[i] == match[i]`. So our input must be such that after all that
  processing and xors , it must be exactly equal to elements of match array.

- Recall that our randomNum array had following numbers before the xmm registers
  overwrote the content inside them

```bash
  pwndbg> x/10d $rsp+0x30
  0x7fffffffe110: 843823140       1075961450      1431043403      1556705910
  0x7fffffffe120: 316356473       85345072        1910202552      1722507678
  0x7fffffffe130: 935851139       783820973
```

- We can easily see the content of match and arr array.

```bash
pwndbg> x/10d &match
0x555555558080 <match>: 911452424       492937848       1148909393      2143955055
0x555555558090 <match+16>:      15278393        641945920       1389854398      65996029
0x5555555580a0 <match+32>:      1204882225      1318260194
pwndbg> x/s &arr
0x5555555580c0 <arr>:   "DeltaForceDeltaForceDeltaForceDeltaForce \345\367\367\377\177"
pwndbg> x/10wd &arr
0x5555555580c0 <arr>:   1953260868      1919895137      1698981219      1180791916
0x5555555580d0 <arr+16>:        1701016175      1953260868      1919895137      1698981219
0x5555555580e0 <arr+32>:        1180791916      1701016175
```

Since all the computations were xors and some random number generations with a
fixed seed, we can easily reverse this to get what our input must be to pass the
checks.

So what we know is

- finalRandomNumArr[i] = inputArr[i] ^ initialRandomNumArr[i] ^ arr[i]; i <-
  0-10
- And finalRandomNumArr[i] should equal match[i] for i=0 to 9. Being equal also
  means, finalRandomNumArr[i] ^ match[i] == 0
- This should give us the input we need to supply

```python
matchArr = list(map(lambda x: int(
    x), '''911452424       492937848       1148909393
           2143955055 15278393        641945920
           1389854398      65996029 1204882225
                    1318260194'''.split()))

initialRandomNumArr = list(map(lambda x: int(
    x), '''843823140       1075961450      1431043403      1556705910 316356473
            85345072 1910202552      1722507678 935851139 783820973'''.split()))

arr = list(map(lambda x: int(x), '''
               1953260868      1919895137      1698981219      1180791916
               1701016175      1953260868      1919895137      1698981219
               1180791916      1701016175'''.strip().split()))

print("The input should be: ")
for i in range(0, 10):
    print(initialRandomNumArr[i] ^ arr[i] ^ matchArr[i])
```

The output of running this script is:

```text
The input should be:
1886680168
791624307
1953853305
1700933237
2001822767
1463383860
1365465191
0
913804254
88626976
```

- Now lets run the program to see what happens.

```bash
Enter 10 numbers to check your luck
1886680168
791624307
1953853305
1700933237
2001822767
1463383860
1365465191
0
913804254
88626976
/bin/cat: flag.txt: No such file or directory
```

- It passed the checks. Now we give these inputs inputs in the server and we get
  our flag.
